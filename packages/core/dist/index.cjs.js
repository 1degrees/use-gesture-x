"use strict";var m=Object.defineProperty;var E=(t,e,s)=>e in t?m(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s;var u=(t,e,s)=>E(t,typeof e!="symbol"?e+"":e,s);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const d=require("./actions-D3YiKN61.cjs"),S={target(t){if(t)return()=>"current"in t?t.current:"value"in t?t.value:t},enabled(t=!0){return t},window(t=d.SUPPORT.isBrowser?window:void 0){return t},eventOptions({passive:t=!0,capture:e=!1}={}){return{passive:t,capture:e}},transform(t){return t}};function v(t={},e){const s={};for(const[n,r]of Object.entries(e))switch(typeof r){case"function":if(process.env.NODE_ENV==="development"){const o=r.call(s,t[n],n,t);Number.isNaN(o)||(s[n]=o)}else s[n]=r.call(s,t[n],n,t);break;case"object":s[n]=v(t[n],r);break;case"boolean":r&&(s[n]=t[n]);break}return s}function b(t,e,s={}){const{target:n,eventOptions:r,window:o,enabled:a,transform:c,...l}=t;if(s.shared=v({target:n,eventOptions:r,window:o,enabled:a,transform:c},S),e){const i=d.ConfigResolverMap.get(e);s[e]=v({shared:s.shared,...l},i)}else for(const i in l){const h=d.ConfigResolverMap.get(i);if(h)s[i]=v({shared:s.shared,...l[i]},h);else if(process.env.NODE_ENV==="development"&&!["drag","pinch","scroll","wheel","move","hover"].includes(i)){if(i==="domTarget")throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");console.warn(`[@use-gesture]: Unknown config key \`${i}\` was used. Please read the documentation for further information.`)}}return s}class w{constructor(e,s){u(this,"_listeners",new Set);u(this,"_ctrl");u(this,"_gestureKey");this._ctrl=e,this._gestureKey=s}add(e,s,n,r,o){const a=this._listeners,c=d.toDomEventType(s,n),i={...this._gestureKey?this._ctrl.config[this._gestureKey].eventOptions:{},...o};e.addEventListener(c,r,i);const h=()=>{e.removeEventListener(c,r,i),a.delete(h)};return a.add(h),h}clean(){this._listeners.forEach(e=>e()),this._listeners.clear()}}class _{constructor(){u(this,"_timeouts",new Map)}add(e,s,n=140,...r){this.remove(e),this._timeouts.set(e,window.setTimeout(s,n,...r))}remove(e){const s=this._timeouts.get(e);s&&window.clearTimeout(s)}clean(){this._timeouts.forEach(e=>void window.clearTimeout(e)),this._timeouts.clear()}}class T{constructor(e){u(this,"gestures",new Set);u(this,"_targetEventStore",new w(this));u(this,"gestureEventStores",{});u(this,"gestureTimeoutStores",{});u(this,"handlers",{});u(this,"nativeHandlers");u(this,"config",{});u(this,"pointerIds",new Set);u(this,"touchIds",new Set);u(this,"state",{shared:{shiftKey:!1,metaKey:!1,ctrlKey:!1,altKey:!1}});y(this,e)}setEventIds(e){if(d.isTouch(e))return this.touchIds=new Set(d.touchIds(e)),this.touchIds;if("pointerId"in e)return e.type==="pointerup"||e.type==="pointercancel"?this.pointerIds.delete(e.pointerId):e.type==="pointerdown"&&this.pointerIds.add(e.pointerId),this.pointerIds}applyHandlers(e,s){this.handlers=e,this.nativeHandlers=s}applyConfig(e,s){this.config=b(e,s,this.config)}clean(){this._targetEventStore.clean();for(const e of this.gestures)this.gestureEventStores[e].clean(),this.gestureTimeoutStores[e].clean()}effect(){return this.config.shared.target&&this.bind(),()=>this._targetEventStore.clean()}bind(...e){const s=this.config.shared,n={};let r;if(!(s.target&&(r=s.target(),!r))){if(s.enabled){for(const a of this.gestures){const c=this.config[a],l=g(n,c.eventOptions,!!r);if(c.enabled){const i=d.EngineMap.get(a);new i(this,e,a).bind(l)}}const o=g(n,s.eventOptions,!!r);for(const a in this.nativeHandlers)o(a,"",c=>this.nativeHandlers[a]({...this.state.shared,event:c,args:e}),void 0,!0)}for(const o in n)n[o]=d.chain(...n[o]);if(!r)return n;for(const o in n){const{device:a,capture:c,passive:l}=d.parseProp(o);this._targetEventStore.add(r,a,"",n[o],{capture:c,passive:l})}}}}function f(t,e){t.gestures.add(e),t.gestureEventStores[e]=new w(t,e),t.gestureTimeoutStores[e]=new _}function y(t,e){e.drag&&f(t,"drag"),e.wheel&&f(t,"wheel"),e.scroll&&f(t,"scroll"),e.move&&f(t,"move"),e.pinch&&f(t,"pinch"),e.hover&&f(t,"hover")}const g=(t,e,s)=>(n,r,o,a={},c=!1)=>{const l=a.capture??e.capture,i=a.passive??e.passive;let h=c?n:d.toHandlerProp(n,r,l);s&&i&&(h+="Passive"),t[h]=t[h]||[],t[h].push(o)},P=/^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;function I(t){const e={},s={},n=new Set;for(let r in t)P.test(r)?(n.add(RegExp.lastMatch),s[r]=t[r]):e[r]=t[r];return[s,e,n]}function p(t,e,s,n,r,o){if(!t.has(s))return;if(!d.EngineMap.has(n)){process.env.NODE_ENV==="development"&&console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${n}\` gesture but isn't properly configured.

Please add \`${n}Action\` when creating your handler.`);return}const a=s+"Start",c=s+"End",l=i=>{let h;return i.first&&a in e&&e[a](i),s in e&&(h=e[s](i)),i.last&&c in e&&e[c](i),h};r[n]=l,o[n]=o[n]||{}}function O(t,e){const[s,n,r]=I(t),o={};return p(r,s,"onDrag","drag",o,e),p(r,s,"onWheel","wheel",o,e),p(r,s,"onScroll","scroll",o,e),p(r,s,"onPinch","pinch",o,e),p(r,s,"onMove","move",o,e),p(r,s,"onHover","hover",o,e),{handlers:o,config:e,nativeHandlers:n}}exports.Controller=T;exports.parseMergedHandlers=O;
