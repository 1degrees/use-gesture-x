{"version":3,"file":"index.js","sources":["../src/utils/events.ts","../src/utils/fn.ts","../src/config/support.ts","../src/actions.ts","../src/config/sharedConfigResolver.ts","../src/config/resolver.ts","../src/EventStore.ts","../src/TimeoutStore.ts","../src/Controller.ts","../src/parser.ts"],"sourcesContent":["import { PointerType } from '../types'\r\nimport { Vector2 } from '../types'\r\n\r\nconst EVENT_TYPE_MAP: any = {\r\n  pointer: { start: 'down', change: 'move', end: 'up' },\r\n  mouse: { start: 'down', change: 'move', end: 'up' },\r\n  touch: { start: 'start', change: 'move', end: 'end' },\r\n  gesture: { start: 'start', change: 'change', end: 'end' }\r\n}\r\n\r\nfunction capitalize(string: string) {\r\n  if (!string) return ''\r\n  return string[0].toUpperCase() + string.slice(1)\r\n}\r\n\r\nconst actionsWithoutCaptureSupported = ['enter', 'leave']\r\n\r\nfunction hasCapture(capture = false, actionKey: string) {\r\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey)\r\n}\r\n\r\nexport function toHandlerProp(device: string, action = '', capture: boolean = false) {\r\n  const deviceProps = EVENT_TYPE_MAP[device]\r\n  const actionKey = deviceProps ? deviceProps[action] || action : action\r\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '')\r\n}\r\n\r\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture']\r\n\r\nexport function parseProp(prop: string) {\r\n  let eventKey = prop.substring(2).toLowerCase()\r\n  const passive = !!~eventKey.indexOf('passive')\r\n  if (passive) eventKey = eventKey.replace('passive', '')\r\n\r\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture'\r\n  // capture = true\r\n  const capture = !!~eventKey.indexOf(captureKey)\r\n  // pointermovecapture => pointermove\r\n  if (capture) eventKey = eventKey.replace('capture', '')\r\n  return { device: eventKey, capture, passive }\r\n}\r\n\r\nexport function toDomEventType(device: string, action = '') {\r\n  const deviceProps = EVENT_TYPE_MAP[device]\r\n  const actionKey = deviceProps ? deviceProps[action] || action : action\r\n  return device + actionKey\r\n}\r\n\r\nexport function isTouch(event: UIEvent) {\r\n  return 'touches' in event\r\n}\r\n\r\nexport function getPointerType(event: UIEvent): PointerType {\r\n  if (isTouch(event)) return 'touch'\r\n  if ('pointerType' in event) return (event as PointerEvent).pointerType as PointerType\r\n  return 'mouse'\r\n}\r\n\r\nfunction getCurrentTargetTouchList(event: TouchEvent) {\r\n  return Array.from(event.touches).filter(\r\n    (e) => e.target === event.currentTarget || (event.currentTarget as Node)?.contains?.(e.target as Node)\r\n  )\r\n}\r\n\r\nfunction getTouchList(event: TouchEvent) {\r\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches\r\n}\r\n\r\nfunction getValueEvent<EventType extends TouchEvent | PointerEvent>(\r\n  event: EventType\r\n): EventType extends TouchEvent ? Touch : PointerEvent {\r\n  return (isTouch(event) ? getTouchList(event as TouchEvent)[0] : event) as any\r\n}\r\n\r\nexport function distanceAngle(P1: Touch | PointerEvent, P2: Touch | PointerEvent) {\r\n  // add a try catch\r\n  // attempt to fix https://github.com/pmndrs/use-gesture/issues/551\r\n  try {\r\n    const dx = P2.clientX - P1.clientX\r\n    const dy = P2.clientY - P1.clientY\r\n    const cx = (P2.clientX + P1.clientX) / 2\r\n    const cy = (P2.clientY + P1.clientY) / 2\r\n\r\n    const distance = Math.hypot(dx, dy)\r\n    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\r\n    const origin = [cx, cy] as Vector2\r\n    return { angle, distance, origin }\r\n  } catch {}\r\n  return null\r\n}\r\n\r\nexport function touchIds(event: TouchEvent) {\r\n  return getCurrentTargetTouchList(event).map((touch) => touch.identifier)\r\n}\r\n\r\nexport function touchDistanceAngle(event: TouchEvent, ids: number[]) {\r\n  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier))\r\n  return distanceAngle(P1, P2)\r\n}\r\n\r\nexport function pointerId(event: PointerEvent | TouchEvent) {\r\n  const valueEvent = getValueEvent(event)\r\n  return isTouch(event) ? (valueEvent as Touch).identifier : (valueEvent as PointerEvent).pointerId\r\n}\r\n\r\nexport function pointerValues(event: PointerEvent | TouchEvent): Vector2 {\r\n  // if ('spaceX' in event) return [event.spaceX, event.spaceY]\r\n  const valueEvent = getValueEvent(event)\r\n  return [valueEvent.clientX, valueEvent.clientY]\r\n}\r\n\r\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\r\nconst LINE_HEIGHT = 40\r\nconst PAGE_HEIGHT = 800\r\n\r\nexport function wheelValues(event: WheelEvent): Vector2 {\r\n  let { deltaX, deltaY, deltaMode } = event\r\n  // normalize wheel values, especially for Firefox\r\n  if (deltaMode === 1) {\r\n    deltaX *= LINE_HEIGHT\r\n    deltaY *= LINE_HEIGHT\r\n  } else if (deltaMode === 2) {\r\n    deltaX *= PAGE_HEIGHT\r\n    deltaY *= PAGE_HEIGHT\r\n  }\r\n  return [deltaX, deltaY]\r\n}\r\n\r\nexport function scrollValues(event: UIEvent): Vector2 {\r\n  // If the currentTarget is the window then we return the scrollX/Y position.\r\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\r\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\r\n  return [scrollX ?? scrollLeft ?? 0, scrollY ?? scrollTop ?? 0]\r\n}\r\n\r\nexport function getEventDetails(event: any) {\r\n  const payload: any = {}\r\n  if ('buttons' in event) payload.buttons = event.buttons\r\n  if ('shiftKey' in event) {\r\n    const { shiftKey, altKey, metaKey, ctrlKey } = event\r\n    Object.assign(payload, { shiftKey, altKey, metaKey, ctrlKey })\r\n  }\r\n  return payload\r\n}\r\n","export function call<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\r\n  if (typeof v === 'function') {\r\n    // @ts-ignore\r\n    return v(...args)\r\n  } else {\r\n    return v\r\n  }\r\n}\r\n\r\nexport function noop() {}\r\n\r\nexport function chain(...fns: Function[]): Function {\r\n  if (fns.length === 0) return noop\r\n  if (fns.length === 1) return fns[0]\r\n\r\n  return function (this: any) {\r\n    let result\r\n    for (const fn of fns) {\r\n      result = fn.apply(this, arguments) || result\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\r\n  return Object.assign({}, fallback, value || {})\r\n}\r\n","const isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\r\n\r\nfunction supportsTouchEvents(): boolean {\r\n  return isBrowser && 'ontouchstart' in window\r\n}\r\n\r\nfunction isTouchScreen(): boolean {\r\n  return supportsTouchEvents() || (isBrowser && window.navigator.maxTouchPoints > 1)\r\n}\r\n\r\nfunction supportsPointerEvents(): boolean {\r\n  return isBrowser && 'onpointerdown' in window\r\n}\r\n\r\nfunction supportsPointerLock(): boolean {\r\n  return isBrowser && 'exitPointerLock' in window.document\r\n}\r\n\r\nfunction supportsGestureEvents(): boolean {\r\n  try {\r\n    // TODO [TS] possibly find GestureEvent definitions?\r\n    // @ts-ignore: no type definitions for webkit GestureEvents\r\n    return 'constructor' in GestureEvent\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nexport const SUPPORT = {\r\n  isBrowser,\r\n  gesture: supportsGestureEvents(),\r\n  /**\r\n   * It looks from https://github.com/pmndrs/use-gesture/discussions/421 that\r\n   * some touchscreens using webkits don't have 'ontouchstart' in window. So\r\n   * we're considering that browsers support TouchEvent if they have\r\n   * `maxTouchPoints > 1`\r\n   *\r\n   * Update 16/09/2023: This generates failure on other Windows systems, so reverting\r\n   * back to detecting TouchEvent support only.\r\n   * https://github.com/pmndrs/use-gesture/issues/626\r\n   */\r\n  touch: supportsTouchEvents(),\r\n  // touch: isTouchScreen(),\r\n  touchscreen: isTouchScreen(),\r\n  pointer: supportsPointerEvents(),\r\n  pointerLock: supportsPointerLock()\r\n}\r\n","import { GestureKey, EngineClass, Action } from './types'\r\nimport { ResolverMap } from './config/resolver'\r\n\r\nimport { DragEngine } from './engines/DragEngine'\r\nimport { dragConfigResolver } from './config/dragConfigResolver'\r\n\r\nimport { PinchEngine } from './engines/PinchEngine'\r\nimport { pinchConfigResolver } from './config/pinchConfigResolver'\r\n\r\nimport { MoveEngine } from './engines/MoveEngine'\r\nimport { moveConfigResolver } from './config/moveConfigResolver'\r\n\r\nimport { ScrollEngine } from './engines/ScrollEngine'\r\nimport { scrollConfigResolver } from './config/scrollConfigResolver'\r\n\r\nimport { WheelEngine } from './engines/WheelEngine'\r\nimport { wheelConfigResolver } from './config/wheelConfigResolver'\r\n\r\nimport { HoverEngine } from './engines/HoverEngine'\r\nimport { hoverConfigResolver } from './config/hoverConfigResolver'\r\n\r\nexport const EngineMap = new Map<GestureKey, EngineClass<any>>()\r\nexport const ConfigResolverMap = new Map<GestureKey, ResolverMap>()\r\n\r\nexport function registerAction(action: Action) {\r\n  EngineMap.set(action.key, action.engine)\r\n  ConfigResolverMap.set(action.key, action.resolver)\r\n}\r\n\r\nexport const dragAction: Action = {\r\n  key: 'drag',\r\n  engine: DragEngine as any,\r\n  resolver: dragConfigResolver\r\n}\r\n\r\nexport const hoverAction: Action = {\r\n  key: 'hover',\r\n  engine: HoverEngine as any,\r\n  resolver: hoverConfigResolver\r\n}\r\n\r\nexport const moveAction: Action = {\r\n  key: 'move',\r\n  engine: MoveEngine as any,\r\n  resolver: moveConfigResolver\r\n}\r\n\r\nexport const pinchAction: Action = {\r\n  key: 'pinch',\r\n  engine: PinchEngine as any,\r\n  resolver: pinchConfigResolver\r\n}\r\n\r\nexport const scrollAction: Action = {\r\n  key: 'scroll',\r\n  engine: ScrollEngine as any,\r\n  resolver: scrollConfigResolver\r\n}\r\n\r\nexport const wheelAction: Action = {\r\n  key: 'wheel',\r\n  engine: WheelEngine as any,\r\n  resolver: wheelConfigResolver\r\n}\r\n","import { Target } from '../types'\r\nimport { SUPPORT } from './support'\r\n\r\nexport const sharedConfigResolver = {\r\n  target(value: Target) {\r\n    if (value) {\r\n      return () => ('current' in value ? value.current : 'value' in value ? value.value : value)\r\n    }\r\n    return undefined\r\n  },\r\n  enabled(value = true) {\r\n    return value\r\n  },\r\n  window(value = SUPPORT.isBrowser ? window : undefined) {\r\n    return value\r\n  },\r\n  eventOptions({ passive = true, capture = false } = {}) {\r\n    return { passive, capture }\r\n  },\r\n  transform(value: any) {\r\n    return value\r\n  }\r\n}\r\n","import { sharedConfigResolver } from './sharedConfigResolver'\r\nimport { ConfigResolverMap } from '../actions'\r\nimport { GestureKey, InternalConfig, UserGestureConfig } from '../types'\r\n\r\nexport type Resolver = (x: any, key: string, obj: any) => any\r\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\r\n\r\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\r\n  config: Partial<T> = {},\r\n  resolvers: ResolverMap\r\n): V {\r\n  const result: any = {}\r\n\r\n  for (const [key, resolver] of Object.entries(resolvers)) {\r\n    switch (typeof resolver) {\r\n      case 'function':\r\n        if (process.env.NODE_ENV === 'development') {\r\n          const r = resolver.call(result, config[key], key, config)\r\n          // prevents deprecated resolvers from applying in dev mode\r\n          if (!Number.isNaN(r)) result[key] = r\r\n        } else {\r\n          result[key] = resolver.call(result, config[key], key, config)\r\n        }\r\n        break\r\n      case 'object':\r\n        result[key] = resolveWith(config[key], resolver)\r\n        break\r\n      case 'boolean':\r\n        if (resolver) result[key] = config[key]\r\n        break\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport function parse(newConfig: UserGestureConfig, gestureKey?: GestureKey, _config: any = {}): InternalConfig {\r\n  const { target, eventOptions, window, enabled, transform, ...rest } = newConfig as any\r\n\r\n  _config.shared = resolveWith({ target, eventOptions, window, enabled, transform }, sharedConfigResolver)\r\n\r\n  if (gestureKey) {\r\n    const resolver = ConfigResolverMap.get(gestureKey)!\r\n    _config[gestureKey] = resolveWith({ shared: _config.shared, ...rest }, resolver)\r\n  } else {\r\n    for (const key in rest) {\r\n      const resolver = ConfigResolverMap.get(key as GestureKey)!\r\n\r\n      if (resolver) {\r\n        _config[key] = resolveWith({ shared: _config.shared, ...rest[key] }, resolver)\r\n      } else if (process.env.NODE_ENV === 'development') {\r\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\r\n          if (key === 'domTarget') {\r\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`)\r\n          }\r\n          // eslint-disable-next-line no-console\r\n          console.warn(\r\n            `[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return _config\r\n}\r\n","import type { Controller } from './Controller'\r\nimport { GestureKey } from './types'\r\nimport { toDomEventType } from './utils/events'\r\n\r\nexport class EventStore {\r\n  private _listeners = new Set<() => void>()\r\n  private _ctrl: Controller\r\n  private _gestureKey?: GestureKey\r\n  constructor(ctrl: Controller, gestureKey?: GestureKey) {\r\n    this._ctrl = ctrl\r\n    this._gestureKey = gestureKey\r\n  }\r\n\r\n  add(\r\n    element: EventTarget,\r\n    device: string,\r\n    action: string,\r\n    handler: (event: any) => void,\r\n    options?: AddEventListenerOptions\r\n  ) {\r\n    const listeners = this._listeners\r\n    const type = toDomEventType(device, action)\r\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey]!.eventOptions : {}\r\n    const eventOptions = { ..._options, ...options }\r\n    element.addEventListener(type, handler, eventOptions)\r\n    const remove = () => {\r\n      element.removeEventListener(type, handler, eventOptions)\r\n      listeners.delete(remove)\r\n    }\r\n    listeners.add(remove)\r\n    return remove\r\n  }\r\n\r\n  clean() {\r\n    this._listeners.forEach((remove) => remove())\r\n    this._listeners.clear() // just for safety\r\n  }\r\n}\r\n","export class TimeoutStore {\r\n  private _timeouts = new Map<string, number>()\r\n\r\n  add<FunctionType extends (...args: any[]) => any>(\r\n    key: string,\r\n    callback: FunctionType,\r\n    ms = 140,\r\n    ...args: Parameters<FunctionType>\r\n  ) {\r\n    this.remove(key)\r\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args))\r\n  }\r\n\r\n  remove(key: string) {\r\n    const timeout = this._timeouts.get(key)\r\n    if (timeout) window.clearTimeout(timeout)\r\n  }\r\n\r\n  clean() {\r\n    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout))\r\n    this._timeouts.clear()\r\n  }\r\n}\r\n","import { EngineMap } from './actions'\nimport { parse } from './config/resolver'\nimport { isTouch, parseProp, toHandlerProp, touchIds } from './utils/events'\nimport { EventStore } from './EventStore'\nimport { TimeoutStore } from './TimeoutStore'\nimport { chain } from './utils/fn'\nimport { GestureKey, InternalConfig, InternalHandlers, NativeHandlers, State, UserGestureConfig } from './types'\n\nexport class Controller {\n  /**\n   * The list of gestures handled by the Controller.\n   */\n  public gestures = new Set<GestureKey>()\n  /**\n   * The event store that keeps track of the config.target listeners.\n   */\n  private _targetEventStore = new EventStore(this)\n  /**\n   * Object that keeps track of all gesture event listeners.\n   */\n  public gestureEventStores: { [key in GestureKey]?: EventStore } = {}\n  public gestureTimeoutStores: { [key in GestureKey]?: TimeoutStore } = {}\n  public handlers: InternalHandlers = {}\n  private nativeHandlers?: NativeHandlers\n  public config = {} as InternalConfig\n  public pointerIds = new Set<number>()\n  public touchIds = new Set<number>()\n  public state = {\n    shared: {\n      shiftKey: false,\n      metaKey: false,\n      ctrlKey: false,\n      altKey: false\n    }\n  } as State\n\n  constructor(handlers: InternalHandlers) {\n    resolveGestures(this, handlers)\n  }\n  /**\n   * Sets pointer or touch ids based on the event.\n   * @param event\n   */\n  setEventIds(event: TouchEvent | PointerEvent) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event as TouchEvent))\n      return this.touchIds\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId)\n      else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId)\n      return this.pointerIds\n    }\n  }\n  /**\n   * Attaches handlers to the controller.\n   * @param handlers\n   * @param nativeHandlers\n   */\n  applyHandlers(handlers: InternalHandlers, nativeHandlers?: NativeHandlers) {\n    this.handlers = handlers\n    this.nativeHandlers = nativeHandlers\n  }\n  /**\n   * Compute and attaches a config to the controller.\n   * @param config\n   * @param gestureKey\n   */\n  applyConfig(config: UserGestureConfig, gestureKey?: GestureKey) {\n    this.config = parse(config, gestureKey, this.config)\n  }\n  /**\n   * Cleans all side effects (listeners, timeouts). When the gesture is\n   * destroyed (in React, when the component is unmounted.)\n   */\n  clean() {\n    this._targetEventStore.clean()\n    for (const key of this.gestures) {\n      this.gestureEventStores[key]!.clean()\n      this.gestureTimeoutStores[key]!.clean()\n    }\n  }\n  /**\n   * Executes side effects (attaching listeners to a `config.target`). Ran on\n   * each render.\n   */\n  effect() {\n    if (this.config.shared.target) this.bind()\n    return () => this._targetEventStore.clean()\n  }\n  /**\n   * The bind function that can be returned by the gesture handler (a hook in\n   * React for example.)\n   * @param args\n   */\n  bind(...args: any[]) {\n    const sharedConfig = this.config.shared\n    const props: any = {}\n\n    let target\n    if (sharedConfig.target) {\n      target = sharedConfig.target()\n      // if target is undefined let's stop\n      if (!target) return\n    }\n\n    if (sharedConfig.enabled) {\n      // Adding gesture handlers\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey]!\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target)\n        if (gestureConfig.enabled) {\n          const Engine = EngineMap.get(gestureKey)!\n          // @ts-ignore\n          new Engine(this, args, gestureKey).bind(bindFunction)\n        }\n      }\n\n      // Adding native handlers\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target)\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(\n          eventKey,\n          '',\n          // @ts-ignore\n          (event) => this.nativeHandlers[eventKey]({ ...this.state.shared, event, args }),\n          undefined,\n          true\n        )\n      }\n    }\n\n    // If target isn't set, we return an object that contains gesture handlers\n    // mapped to props handler event keys.\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp])\n    }\n\n    // When target isn't specified then return hanlder props.\n    if (!target) return props\n\n    // When target is specified, then add listeners to the controller target\n    // store.\n    for (const handlerProp in props) {\n      const { device, capture, passive } = parseProp(handlerProp)\n      this._targetEventStore.add(target, device, '', props[handlerProp], { capture, passive })\n    }\n  }\n}\n\nfunction setupGesture(ctrl: Controller, gestureKey: GestureKey) {\n  ctrl.gestures.add(gestureKey)\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey)\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore()\n}\n\nfunction resolveGestures(ctrl: Controller, internalHandlers: InternalHandlers) {\n  // make sure hover handlers are added first to prevent bugs such as #322\n  // where the hover pointerLeave handler is removed before the move\n  // pointerLeave, which prevents hovering: false to be fired.\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag')\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel')\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll')\n  if (internalHandlers.move) setupGesture(ctrl, 'move')\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch')\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover')\n}\n\nconst bindToProps =\n  (props: any, eventOptions: AddEventListenerOptions, withPassiveOption: boolean) =>\n  (\n    device: string,\n    action: string,\n    handler: (event: any) => void,\n    options: AddEventListenerOptions = {},\n    isNative = false\n  ) => {\n    const capture = options.capture ?? eventOptions.capture\n    const passive = options.passive ?? eventOptions.passive\n    // a native handler is already passed as a prop like \"onMouseDown\"\n    let handlerProp = isNative ? device : toHandlerProp(device, action, capture)\n    if (withPassiveOption && passive) handlerProp += 'Passive'\n    props[handlerProp] = props[handlerProp] || []\n    props[handlerProp].push(handler)\n  }\n","import { FullGestureState, GestureHandlers, GestureKey, InternalHandlers, UserGestureConfig } from './types'\r\nimport { EngineMap } from './actions'\r\n\r\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\r\n\r\nfunction sortHandlers(_handlers: GestureHandlers) {\r\n  const native: any = {}\r\n  const handlers: InternalHandlers = {}\r\n  const actions = new Set()\r\n\r\n  for (let key in _handlers) {\r\n    if (RE_NOT_NATIVE.test(key)) {\r\n      actions.add(RegExp.lastMatch)\r\n      // @ts-ignore\r\n      handlers[key] = _handlers[key]\r\n    } else {\r\n      // @ts-ignore\r\n      native[key] = _handlers[key]\r\n    }\r\n  }\r\n\r\n  return [handlers, native, actions]\r\n}\r\n\r\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\r\n\r\nfunction registerGesture(\r\n  actions: Set<unknown>,\r\n  handlers: GestureHandlers,\r\n  handlerKey: HandlerKey,\r\n  key: GestureKey,\r\n  internalHandlers: any,\r\n  config: any\r\n) {\r\n  if (!actions.has(handlerKey)) return\r\n\r\n  if (!EngineMap.has(key)) {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`\r\n      )\r\n    }\r\n    return\r\n  }\r\n\r\n  const startKey = handlerKey + 'Start'\r\n  const endKey = handlerKey + 'End'\r\n\r\n  const fn = (state: FullGestureState<GestureKey>) => {\r\n    let memo = undefined\r\n    // @ts-ignore\r\n    if (state.first && startKey in handlers) handlers[startKey](state)\r\n    // @ts-ignore\r\n    if (handlerKey in handlers) memo = handlers[handlerKey](state)\r\n    // @ts-ignore\r\n    if (state.last && endKey in handlers) handlers[endKey](state)\r\n    return memo\r\n  }\r\n\r\n  internalHandlers[key] = fn\r\n  config[key] = config[key] || {}\r\n}\r\n\r\nexport function parseMergedHandlers(mergedHandlers: GestureHandlers, mergedConfig: UserGestureConfig) {\r\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers)\r\n\r\n  const internalHandlers = {}\r\n\r\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig)\r\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig)\r\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig)\r\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig)\r\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig)\r\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig)\r\n\r\n  return { handlers: internalHandlers, config: mergedConfig, nativeHandlers }\r\n}\r\n"],"names":["EVENT_TYPE_MAP","capitalize","string","actionsWithoutCaptureSupported","hasCapture","capture","actionKey","toHandlerProp","device","action","deviceProps","pointerCaptureEvents","parseProp","prop","eventKey","passive","captureKey","toDomEventType","isTouch","event","getCurrentTargetTouchList","_a","_b","touchIds","touch","noop","chain","fns","result","fn","isBrowser","supportsTouchEvents","isTouchScreen","supportsPointerEvents","supportsPointerLock","supportsGestureEvents","SUPPORT","EngineMap","ConfigResolverMap","sharedConfigResolver","value","resolveWith","config","resolvers","key","resolver","r","parse","newConfig","gestureKey","_config","target","eventOptions","window","enabled","transform","rest","EventStore","ctrl","__publicField","element","handler","options","listeners","type","remove","TimeoutStore","callback","ms","args","timeout","Controller","handlers","resolveGestures","nativeHandlers","sharedConfig","props","gestureConfig","bindFunction","bindToProps","Engine","nativeBindFunction","handlerProp","setupGesture","internalHandlers","withPassiveOption","isNative","RE_NOT_NATIVE","sortHandlers","_handlers","native","actions","registerGesture","handlerKey","startKey","endKey","state","memo","parseMergedHandlers","mergedHandlers","mergedConfig"],"mappings":"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"}